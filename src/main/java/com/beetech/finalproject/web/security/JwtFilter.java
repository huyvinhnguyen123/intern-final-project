package com.beetech.finalproject.web.security;

import com.beetech.finalproject.domain.entities.User;
import com.beetech.finalproject.domain.repository.UserRepository;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.jetbrains.annotations.NotNull;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
@RequiredArgsConstructor
public class JwtFilter extends OncePerRequestFilter {
    private final UserRepository userRepository;
    private final JwtUtils jwtUtils;

    /**
     * Implementation of function do filter
     *
     * @param request Servlet request
     * @param response Servlet response
     * @param filterChain filter chain
     * @throws ServletException - error
     * @throws IOException - error
     */
    @Override
    protected void doFilterInternal(HttpServletRequest request, @NotNull HttpServletResponse response, @NotNull FilterChain filterChain) throws ServletException, IOException {
        // declare token header
        // the "Authorization" header is used by default to send authentication credentials
        // such as a JWT token or a Basic Authentication header,
        // from the client to the server for authentication a
        final String tokenHeader = request.getHeader("Authorization");
        // declare token
        final String token;
        // declare email
        final String loginId;

        // token is sent through header authentication
        // if request.getHeader is null or tokenHeader is not start with "Bearer"
        // the "Bearer" token is a cryptic string, usually generated by the spring security in response to a login request
        // the client must send this token in the Authorization header when making requests to protected resources:
        // Authorization: Bearer <token>
        if(tokenHeader == null || !tokenHeader.startsWith("Bearer ")) {
            filterChain.doFilter(request, response);
            return;
        }

        // remove word "Bearer" and space to get jwt token
        // because "Bearer" has 6 index then the beginning index should start with 7
        token = tokenHeader.substring(7);
        // extract email from token
        loginId = jwtUtils.extractUsername(token);
        // and if email is not null and has not authentication
        if(loginId != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            // find email in database
            User user = userRepository.findByLoginId(loginId);
            // validate token
            if(Boolean.TRUE.equals(jwtUtils.validateToken(token, user))) {
                // set object to authenticate
                UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user, null, user.getAuthorities());
                authenticationToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authenticationToken);
            }
        }
        filterChain.doFilter(request, response);
    }
}
